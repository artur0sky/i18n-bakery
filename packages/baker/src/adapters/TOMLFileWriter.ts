/**
 * ðŸ¥¯ i18n-bakery - TOML File Writer (Adapter Layer)
 * 
 * Concrete implementation of the FileWriter interface for TOML format.
 * Handles reading, writing, and merging TOML translation files.
 * 
 * This implementation is completely dependency-free, implementing TOML
 * serialization and deserialization from scratch following the TOML v1.0.0 spec.
 * 
 * @module adapters/TOMLFileWriter
 */

import {
  FileWriter,
  FileWriterConfig,
  TranslationFileContent,
  FileSystemManager,
} from '../domain/FileWriter';

/**
 * TOML-based implementation of the FileWriter interface.
 * 
 * This adapter handles TOML file operations with support for:
 * - TOML v1.0.0 specification compliance
 * - Pretty-printing with configurable indentation
 * - Append-only mode to prevent overwriting manual edits
 * - Automatic directory creation
 * - Deep merging of translation variants
 * - Zero external dependencies
 * 
 * TOML Format Example:
 * ```toml
 * [title.variants.meal]
 * value = "{{meal}}"
 * variables = ["meal"]
 * autoGenerated = true
 * timestamp = 1234567890
 * ```
 */
export class TOMLFileWriter implements FileWriter {
  private config: Required<FileWriterConfig>;
  private fsManager: FileSystemManager;

  /**
   * Creates a new TOMLFileWriter.
   * 
   * @param fsManager - File system manager for directory operations
   * @param config - Configuration options
   */
  constructor(fsManager: FileSystemManager, config?: Partial<FileWriterConfig>) {
    this.fsManager = fsManager;
    this.config = {
      format: 'toml',
      prettyPrint: config?.prettyPrint ?? true,
      indentSize: config?.indentSize ?? 2,
      createDirectories: config?.createDirectories ?? true,
    };
  }

  /**
   * Writes translation content to a TOML file.
   * 
   * @param filePath - Absolute path to the file
   * @param content - Translation content to write
   */
  async write(filePath: string, content: TranslationFileContent): Promise<void> {
    // Security: Enforce .toml extension
    if (!filePath.endsWith('.toml')) {
      throw new Error(`Security Error: TOMLFileWriter only supports .toml files. Attempted to write: ${filePath}`);
    }

    // Ensure directory exists
    if (this.config.createDirectories) {
      const dirPath = this.fsManager.getDirectoryPath(filePath);
      if (!(await this.fsManager.directoryExists(dirPath))) {
        await this.fsManager.createDirectory(dirPath);
      }
    }

    // Serialize content
    const tomlString = this.serialize(content);

    // Write to file
    await this.writeFile(filePath, tomlString);
  }

  /**
   * Reads translation content from a TOML file.
   * 
   * @param filePath - Absolute path to the file
   * @returns Promise that resolves with the file content, or null if file doesn't exist
   */
  async read(filePath: string): Promise<TranslationFileContent | null> {
    if (!(await this.exists(filePath))) {
      return null;
    }

    const fileContent = await this.readFile(filePath);
    return this.deserialize(fileContent);
  }

  /**
   * Checks if a file exists.
   * 
   * @param filePath - Absolute path to the file
   * @returns Promise that resolves with true if file exists
   */
  async exists(filePath: string): Promise<boolean> {
    try {
      await this.readFile(filePath);
      return true;
    } catch {
      return false;
    }
  }

  /**
   * Merges new content with existing file content.
   * 
   * @param filePath - Absolute path to the file
   * @param newContent - New content to merge
   * @param mode - Merge mode: 'append' (don't overwrite) or 'replace' (overwrite)
   */
  async merge(
    filePath: string,
    newContent: TranslationFileContent,
    mode: 'append' | 'replace'
  ): Promise<void> {
    const existingContent = await this.read(filePath);

    if (!existingContent) {
      // File doesn't exist, just write new content
      await this.write(filePath, newContent);
      return;
    }

    const mergedContent = this.mergeContent(existingContent, newContent, mode);
    await this.write(filePath, mergedContent);
  }

  /**
   * Serializes translation content to TOML string.
   * 
   * @param content - Translation content
   * @returns TOML string
   */
  private serialize(content: TranslationFileContent): string {
    const lines: string[] = [];
    const indent = this.config.prettyPrint ? ' '.repeat(this.config.indentSize) : '';

    // Sort keys for consistent output
    const sortedKeys = Object.keys(content).sort();

    for (const key of sortedKeys) {
      const entry = content[key];
      
      // Security: Prevent prototype pollution
      if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
        continue;
      }

      // Sort variant keys
      const variantKeys = Object.keys(entry.variants).sort();

      for (const variantKey of variantKeys) {
        // Security: Prevent prototype pollution in variants
        if (variantKey === '__proto__' || variantKey === 'constructor' || variantKey === 'prototype') {
          continue;
        }

        const variant = entry.variants[variantKey];
        
        // Create table header: [key.variants.variantKey]
        const tableName = this.escapeKey(key) + '.variants.' + this.escapeKey(variantKey);
        lines.push(`[${tableName}]`);

        // Add variant properties
        lines.push(`value = ${this.serializeValue(variant.value)}`);
        lines.push(`variables = ${this.serializeArray(variant.variables)}`);
        
        if (variant.autoGenerated !== undefined) {
          lines.push(`autoGenerated = ${variant.autoGenerated}`);
        }
        
        if (variant.timestamp !== undefined) {
          lines.push(`timestamp = ${variant.timestamp}`);
        }

        // Add blank line between tables for readability
        if (this.config.prettyPrint) {
          lines.push('');
        }
      }
    }

    // Remove trailing blank line
    if (lines[lines.length - 1] === '') {
      lines.pop();
    }

    return lines.join('\n') + '\n';
  }

  /**
   * Deserializes TOML string to translation content.
   * 
   * @param tomlString - TOML string
   * @returns Translation content
   */
  private deserialize(tomlString: string): TranslationFileContent {
    const content: TranslationFileContent = {};
    const lines = tomlString.split('\n');
    
    let currentTable: string | null = null;
    let currentKey: string | null = null;
    let currentVariantKey: string | null = null;

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();

      // Skip empty lines and comments
      if (!line || line.startsWith('#')) {
        continue;
      }

      // Parse table header: [key.variants.variantKey]
      if (line.startsWith('[') && line.endsWith(']')) {
        currentTable = line.slice(1, -1);
        const parts = this.parseTableName(currentTable);
        
        if (parts) {
          currentKey = parts.key;
          currentVariantKey = parts.variantKey;

          // Initialize structure if needed
          if (!content[currentKey]) {
            content[currentKey] = { variants: {} };
          }
          if (!content[currentKey].variants[currentVariantKey]) {
            content[currentKey].variants[currentVariantKey] = {
              value: '',
              variables: [],
            };
          }
        }
        continue;
      }

      // Parse key-value pair
      if (currentKey && currentVariantKey) {
        const kvMatch = line.match(/^([^=]+?)\s*=\s*(.+)$/);
        if (kvMatch) {
          const [, key, value] = kvMatch;
          const trimmedKey = key.trim();
          const trimmedValue = value.trim();

          const variant = content[currentKey].variants[currentVariantKey];

          switch (trimmedKey) {
            case 'value':
              variant.value = this.deserializeValue(trimmedValue);
              break;
            case 'variables':
              variant.variables = this.deserializeArray(trimmedValue);
              break;
            case 'autoGenerated':
              variant.autoGenerated = trimmedValue === 'true';
              break;
            case 'timestamp':
              variant.timestamp = parseInt(trimmedValue, 10);
              break;
          }
        }
      }
    }

    return content;
  }

  /**
   * Merges two translation contents based on the specified mode.
   * 
   * @param existing - Existing content
   * @param newContent - New content to merge
   * @param mode - Merge mode
   * @returns Merged content
   */
  private mergeContent(
    existing: TranslationFileContent,
    newContent: TranslationFileContent,
    mode: 'append' | 'replace'
  ): TranslationFileContent {
    const result: TranslationFileContent = { ...existing };

    for (const [key, newEntry] of Object.entries(newContent)) {
      // Security: Prevent prototype pollution
      if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
        continue;
      }

      if (!result[key]) {
        // Key doesn't exist, add it
        result[key] = newEntry;
        continue;
      }

      // Key exists, merge variants
      for (const [signatureKey, newVariant] of Object.entries(newEntry.variants)) {
        // Security: Prevent prototype pollution in variants
        if (signatureKey === '__proto__' || signatureKey === 'constructor' || signatureKey === 'prototype') {
          continue;
        }

        if (mode === 'append' && result[key].variants[signatureKey]) {
          // Append mode: don't overwrite existing variants
          continue;
        }

        // Add or replace variant
        result[key].variants[signatureKey] = newVariant;
      }
    }

    return result;
  }

  /**
   * Escapes a key for use in TOML table names.
   * Keys with special characters must be quoted.
   * 
   * @param key - Key to escape
   * @returns Escaped key
   */
  private escapeKey(key: string): string {
    // Check if key needs quoting (contains special characters)
    if (/^[A-Za-z0-9_-]+$/.test(key)) {
      return key;
    }
    
    // Quote and escape the key
    return '"' + key.replace(/\\/g, '\\\\').replace(/"/g, '\\"') + '"';
  }

  /**
   * Serializes a string value for TOML.
   * 
   * @param value - Value to serialize
   * @returns Serialized value
   */
  private serializeValue(value: string): string {
    // Escape special characters
    const escaped = value
      .replace(/\\/g, '\\\\')
      .replace(/"/g, '\\"')
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '\\r')
      .replace(/\t/g, '\\t');
    
    return `"${escaped}"`;
  }

  /**
   * Deserializes a TOML string value.
   * 
   * @param value - Serialized value
   * @returns Deserialized value
   */
  private deserializeValue(value: string): string {
    // Remove quotes
    if (value.startsWith('"') && value.endsWith('"')) {
      value = value.slice(1, -1);
    }

    // Unescape special characters
    return value
      .replace(/\\n/g, '\n')
      .replace(/\\r/g, '\r')
      .replace(/\\t/g, '\t')
      .replace(/\\"/g, '"')
      .replace(/\\\\/g, '\\');
  }

  /**
   * Serializes an array for TOML.
   * 
   * @param arr - Array to serialize
   * @returns Serialized array
   */
  private serializeArray(arr: string[]): string {
    const items = arr.map(item => this.serializeValue(item));
    return '[' + items.join(', ') + ']';
  }

  /**
   * Deserializes a TOML array.
   * 
   * @param value - Serialized array
   * @returns Deserialized array
   */
  private deserializeArray(value: string): string[] {
    // Remove brackets
    if (value.startsWith('[') && value.endsWith(']')) {
      value = value.slice(1, -1).trim();
    }

    if (!value) {
      return [];
    }

    // Split by comma and deserialize each item
    const items: string[] = [];
    let current = '';
    let inQuotes = false;
    let escaped = false;

    for (let i = 0; i < value.length; i++) {
      const char = value[i];

      if (escaped) {
        current += char;
        escaped = false;
        continue;
      }

      if (char === '\\') {
        current += char;
        escaped = true;
        continue;
      }

      if (char === '"') {
        current += char;
        inQuotes = !inQuotes;
        continue;
      }

      if (char === ',' && !inQuotes) {
        items.push(this.deserializeValue(current.trim()));
        current = '';
        continue;
      }

      current += char;
    }

    // Add last item
    if (current.trim()) {
      items.push(this.deserializeValue(current.trim()));
    }

    return items;
  }

  /**
   * Parses a TOML table name to extract key and variant key.
   * Expected format: key.variants.variantKey
   * 
   * @param tableName - Table name to parse
   * @returns Parsed components or null if invalid
   */
  private parseTableName(tableName: string): { key: string; variantKey: string } | null {
    // Handle quoted keys
    const parts: string[] = [];
    let current = '';
    let inQuotes = false;

    for (let i = 0; i < tableName.length; i++) {
      const char = tableName[i];

      if (char === '"') {
        inQuotes = !inQuotes;
        continue;
      }

      if (char === '.' && !inQuotes) {
        if (current) {
          parts.push(current);
          current = '';
        }
        continue;
      }

      current += char;
    }

    if (current) {
      parts.push(current);
    }

    // Expected format: [key, "variants", variantKey]
    if (parts.length >= 3 && parts[parts.length - 2] === 'variants') {
      const variantKey = parts[parts.length - 1];
      const key = parts.slice(0, parts.length - 2).join('.');
      return { key, variantKey };
    }

    return null;
  }

  /**
   * Writes string content to a file.
   * 
   * @param filePath - Absolute path to the file
   * @param content - String content to write
   */
  private async writeFile(filePath: string, content: string): Promise<void> {
    if (typeof window === 'undefined') {
      // Node.js environment
      const fs = await import('fs/promises');
      await fs.writeFile(filePath, content, 'utf-8');
    } else {
      // Browser environment - not supported
      throw new Error('File writing is not supported in browser environment');
    }
  }

  /**
   * Reads string content from a file.
   * 
   * @param filePath - Absolute path to the file
   * @returns String content
   */
  private async readFile(filePath: string): Promise<string> {
    if (typeof window === 'undefined') {
      // Node.js environment
      const fs = await import('fs/promises');
      return await fs.readFile(filePath, 'utf-8');
    } else {
      // Browser environment - not supported
      throw new Error('File reading is not supported in browser environment');
    }
  }
}
