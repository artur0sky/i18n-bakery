/**
 * ðŸ¥¯ i18n-bakery - TOML File Writer Tests
 * 
 * Comprehensive tests for the TOMLFileWriter adapter.
 * Tests serialization, deserialization, merging, and security features.
 */

import { describe, it, expect, beforeEach } from 'vitest';
import { TOMLFileWriter } from '../src/adapters/TOMLFileWriter';
import { NodeFileSystemManager } from '../src/adapters/NodeFileSystemManager';
import { TranslationFileContent, VariantContent } from '../src/domain/FileWriter';
import fs from 'fs/promises';
import path from 'path';
import os from 'os';

describe('TOMLFileWriter', () => {
  let writer: TOMLFileWriter;
  let fsManager: NodeFileSystemManager;
  let testDir: string;

  beforeEach(async () => {
    // Create a temporary directory for tests
    testDir = path.join(os.tmpdir(), `i18n-bakery-test-${Date.now()}`);
    await fs.mkdir(testDir, { recursive: true });

    fsManager = new NodeFileSystemManager();
    writer = new TOMLFileWriter(fsManager, {
      format: 'toml',
      prettyPrint: true,
      indentSize: 2,
      createDirectories: true,
    });
  });

  describe('Security', () => {
    it('should only accept .toml file extensions', async () => {
      const content: TranslationFileContent = {
        title: {
          variants: {
            default: { value: 'Hello', variables: [] },
          },
        },
      };

      const invalidPath = path.join(testDir, 'test.json');
      
      await expect(writer.write(invalidPath, content)).rejects.toThrow(
        'Security Error: TOMLFileWriter only supports .toml files'
      );
    });

    it('should prevent prototype pollution in keys', async () => {
      const maliciousContent: any = {
        __proto__: {
          variants: {
            default: { value: 'malicious', variables: [] },
          },
        },
        constructor: {
          variants: {
            default: { value: 'malicious', variables: [] },
          },
        },
        prototype: {
          variants: {
            default: { value: 'malicious', variables: [] },
          },
        },
        safe: {
          variants: {
            default: { value: 'safe value', variables: [] },
          },
        },
      };

      const filePath = path.join(testDir, 'security.toml');
      await writer.write(filePath, maliciousContent);

      const content = await fs.readFile(filePath, 'utf-8');
      
      // Should not contain dangerous keys
      expect(content).not.toContain('__proto__');
      expect(content).not.toContain('constructor');
      expect(content).not.toContain('prototype');
      
      // Should contain safe key
      expect(content).toContain('safe');
    });

    it('should prevent prototype pollution in variant keys', async () => {
      const maliciousContent: TranslationFileContent = {
        title: {
          variants: {
            __proto__: { value: 'malicious', variables: [] },
            constructor: { value: 'malicious', variables: [] },
            prototype: { value: 'malicious', variables: [] },
            safe: { value: 'safe value', variables: [] },
          },
        },
      };

      const filePath = path.join(testDir, 'security-variants.toml');
      await writer.write(filePath, maliciousContent);

      const content = await fs.readFile(filePath, 'utf-8');
      
      // Should contain safe variant
      expect(content).toContain('[title.variants.safe]');
      
      // Should not contain dangerous variants
      expect(content).not.toContain('__proto__');
      expect(content).not.toContain('[title.variants.constructor]');
      expect(content).not.toContain('[title.variants.prototype]');
    });
  });

  describe('Serialization', () => {
    it('should serialize simple translation content', async () => {
      const content: TranslationFileContent = {
        title: {
          variants: {
            default: {
              value: 'Welcome',
              variables: [],
              autoGenerated: true,
              timestamp: 1234567890,
            },
          },
        },
      };

      const filePath = path.join(testDir, 'simple.toml');
      await writer.write(filePath, content);

      const fileContent = await fs.readFile(filePath, 'utf-8');
      
      expect(fileContent).toContain('[title.variants.default]');
      expect(fileContent).toContain('value = "Welcome"');
      expect(fileContent).toContain('variables = []');
      expect(fileContent).toContain('autoGenerated = true');
      expect(fileContent).toContain('timestamp = 1234567890');
    });

    it('should serialize translation with variables', async () => {
      const content: TranslationFileContent = {
        greeting: {
          variants: {
            name: {
              value: 'Hello, {{name}}!',
              variables: ['name'],
              autoGenerated: false,
            },
          },
        },
      };

      const filePath = path.join(testDir, 'variables.toml');
      await writer.write(filePath, content);

      const fileContent = await fs.readFile(filePath, 'utf-8');
      
      expect(fileContent).toContain('[greeting.variants.name]');
      expect(fileContent).toContain('value = "Hello, {{name}}!"');
      expect(fileContent).toContain('variables = ["name"]');
      expect(fileContent).toContain('autoGenerated = false');
    });

    it('should serialize multiple variants', async () => {
      const content: TranslationFileContent = {
        meal: {
          variants: {
            default: {
              value: '{{meal}}',
              variables: ['meal'],
            },
            'meal_price': {
              value: '{{meal}} - ${{price}}',
              variables: ['meal', 'price'],
            },
          },
        },
      };

      const filePath = path.join(testDir, 'multiple-variants.toml');
      await writer.write(filePath, content);

      const fileContent = await fs.readFile(filePath, 'utf-8');
      
      expect(fileContent).toContain('[meal.variants.default]');
      expect(fileContent).toContain('value = "{{meal}}"');
      expect(fileContent).toContain('[meal.variants.meal_price]');
      expect(fileContent).toContain('value = "{{meal}} - ${{price}}"');
      expect(fileContent).toContain('variables = ["meal", "price"]');
    });

    it('should escape special characters in values', async () => {
      const content: TranslationFileContent = {
        special: {
          variants: {
            default: {
              value: 'Line 1\nLine 2\tTabbed\r\nWindows\\"Quoted\\"\\Backslash',
              variables: [],
            },
          },
        },
      };

      const filePath = path.join(testDir, 'special-chars.toml');
      await writer.write(filePath, content);

      const fileContent = await fs.readFile(filePath, 'utf-8');
      
      expect(fileContent).toContain('\\n');
      expect(fileContent).toContain('\\t');
      expect(fileContent).toContain('\\r');
      expect(fileContent).toContain('\\"');
      expect(fileContent).toContain('\\\\');
    });

    it('should quote keys with special characters', async () => {
      const content: TranslationFileContent = {
        'key-with-dash': {
          variants: {
            'variant.with.dots': {
              value: 'Test',
              variables: [],
            },
          },
        },
      };

      const filePath = path.join(testDir, 'special-keys.toml');
      await writer.write(filePath, content);

      const fileContent = await fs.readFile(filePath, 'utf-8');
      
      // Keys with dashes don't need quoting, but keys with dots do
      expect(fileContent).toMatch(/\[key-with-dash\.variants\."variant\.with\.dots"\]/);
    });

    it('should sort keys alphabetically', async () => {
      const content: TranslationFileContent = {
        zebra: {
          variants: {
            default: { value: 'Z', variables: [] },
          },
        },
        apple: {
          variants: {
            default: { value: 'A', variables: [] },
          },
        },
        banana: {
          variants: {
            default: { value: 'B', variables: [] },
          },
        },
      };

      const filePath = path.join(testDir, 'sorted.toml');
      await writer.write(filePath, content);

      const fileContent = await fs.readFile(filePath, 'utf-8');
      const appleIndex = fileContent.indexOf('[apple.variants.default]');
      const bananaIndex = fileContent.indexOf('[banana.variants.default]');
      const zebraIndex = fileContent.indexOf('[zebra.variants.default]');
      
      expect(appleIndex).toBeLessThan(bananaIndex);
      expect(bananaIndex).toBeLessThan(zebraIndex);
    });
  });

  describe('Deserialization', () => {
    it('should deserialize simple TOML content', async () => {
      const tomlContent = `[title.variants.default]
value = "Welcome"
variables = []
autoGenerated = true
timestamp = 1234567890
`;

      const filePath = path.join(testDir, 'deserialize-simple.toml');
      await fs.writeFile(filePath, tomlContent, 'utf-8');

      const content = await writer.read(filePath);
      
      expect(content).toBeDefined();
      expect(content!.title).toBeDefined();
      expect(content!.title.variants.default).toBeDefined();
      expect(content!.title.variants.default.value).toBe('Welcome');
      expect(content!.title.variants.default.variables).toEqual([]);
      expect(content!.title.variants.default.autoGenerated).toBe(true);
      expect(content!.title.variants.default.timestamp).toBe(1234567890);
    });

    it('should deserialize TOML with variables', async () => {
      const tomlContent = `[greeting.variants.name]
value = "Hello, {{name}}!"
variables = ["name"]
autoGenerated = false
`;

      const filePath = path.join(testDir, 'deserialize-vars.toml');
      await fs.writeFile(filePath, tomlContent, 'utf-8');

      const content = await writer.read(filePath);
      
      expect(content!.greeting.variants.name.value).toBe('Hello, {{name}}!');
      expect(content!.greeting.variants.name.variables).toEqual(['name']);
      expect(content!.greeting.variants.name.autoGenerated).toBe(false);
    });

    it('should deserialize escaped special characters', async () => {
      const tomlContent = `[special.variants.default]
value = "Line 1\\nLine 2\\tTabbed\\r\\nWindows\\"Quoted\\"\\\\Backslash"
variables = []
`;

      const filePath = path.join(testDir, 'deserialize-special.toml');
      await fs.writeFile(filePath, tomlContent, 'utf-8');

      const content = await writer.read(filePath);
      
      expect(content!.special.variants.default.value).toBe(
        'Line 1\nLine 2\tTabbed\r\nWindows"Quoted"\\Backslash'
      );
    });

    it('should handle comments and empty lines', async () => {
      const tomlContent = `# This is a comment

[title.variants.default]
# Another comment
value = "Welcome"
variables = []

# More comments
`;

      const filePath = path.join(testDir, 'deserialize-comments.toml');
      await fs.writeFile(filePath, tomlContent, 'utf-8');

      const content = await writer.read(filePath);
      
      expect(content!.title.variants.default.value).toBe('Welcome');
    });

    it('should return null for non-existent files', async () => {
      const filePath = path.join(testDir, 'non-existent.toml');
      const content = await writer.read(filePath);
      
      expect(content).toBeNull();
    });
  });

  describe('Round-trip', () => {
    it('should maintain data integrity through write-read cycle', async () => {
      const originalContent: TranslationFileContent = {
        greeting: {
          variants: {
            default: {
              value: 'Hello',
              variables: [],
              autoGenerated: true,
              timestamp: 1234567890,
            },
            name: {
              value: 'Hello, {{name}}!',
              variables: ['name'],
              autoGenerated: false,
              timestamp: 1234567891,
            },
          },
        },
        farewell: {
          variants: {
            default: {
              value: 'Goodbye',
              variables: [],
            },
          },
        },
      };

      const filePath = path.join(testDir, 'roundtrip.toml');
      
      // Write
      await writer.write(filePath, originalContent);
      
      // Read
      const readContent = await writer.read(filePath);
      
      // Verify
      expect(readContent).toEqual(originalContent);
    });
  });

  describe('Merging', () => {
    it('should merge new content in append mode', async () => {
      const existingContent: TranslationFileContent = {
        title: {
          variants: {
            default: { value: 'Original Title', variables: [] },
          },
        },
      };

      const newContent: TranslationFileContent = {
        title: {
          variants: {
            default: { value: 'New Title', variables: [] },
            name: { value: 'Title for {{name}}', variables: ['name'] },
          },
        },
        subtitle: {
          variants: {
            default: { value: 'Subtitle', variables: [] },
          },
        },
      };

      const filePath = path.join(testDir, 'merge-append.toml');
      
      // Write existing content
      await writer.write(filePath, existingContent);
      
      // Merge new content in append mode
      await writer.merge(filePath, newContent, 'append');
      
      // Read result
      const result = await writer.read(filePath);
      
      // Original variant should be preserved
      expect(result!.title.variants.default.value).toBe('Original Title');
      
      // New variant should be added
      expect(result!.title.variants.name.value).toBe('Title for {{name}}');
      
      // New key should be added
      expect(result!.subtitle.variants.default.value).toBe('Subtitle');
    });

    it('should merge new content in replace mode', async () => {
      const existingContent: TranslationFileContent = {
        title: {
          variants: {
            default: { value: 'Original Title', variables: [] },
          },
        },
      };

      const newContent: TranslationFileContent = {
        title: {
          variants: {
            default: { value: 'New Title', variables: [] },
          },
        },
      };

      const filePath = path.join(testDir, 'merge-replace.toml');
      
      // Write existing content
      await writer.write(filePath, existingContent);
      
      // Merge new content in replace mode
      await writer.merge(filePath, newContent, 'replace');
      
      // Read result
      const result = await writer.read(filePath);
      
      // Variant should be replaced
      expect(result!.title.variants.default.value).toBe('New Title');
    });

    it('should create file if it does not exist during merge', async () => {
      const newContent: TranslationFileContent = {
        title: {
          variants: {
            default: { value: 'New Title', variables: [] },
          },
        },
      };

      const filePath = path.join(testDir, 'merge-new.toml');
      
      // Merge to non-existent file
      await writer.merge(filePath, newContent, 'append');
      
      // Read result
      const result = await writer.read(filePath);
      
      expect(result!.title.variants.default.value).toBe('New Title');
    });
  });

  describe('File System Operations', () => {
    it('should create directories automatically', async () => {
      const content: TranslationFileContent = {
        title: {
          variants: {
            default: { value: 'Test', variables: [] },
          },
        },
      };

      const filePath = path.join(testDir, 'deep', 'nested', 'path', 'test.toml');
      
      await writer.write(filePath, content);
      
      const exists = await writer.exists(filePath);
      expect(exists).toBe(true);
    });

    it('should check file existence correctly', async () => {
      const filePath = path.join(testDir, 'exists-test.toml');
      
      // Should not exist initially
      expect(await writer.exists(filePath)).toBe(false);
      
      // Write file
      await writer.write(filePath, {
        test: {
          variants: {
            default: { value: 'Test', variables: [] },
          },
        },
      });
      
      // Should exist now
      expect(await writer.exists(filePath)).toBe(true);
    });
  });
});
