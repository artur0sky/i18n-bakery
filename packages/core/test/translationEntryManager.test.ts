/**
 * ðŸ¥¯ i18n-bakery - Translation Entry Manager Tests
 * 
 * Comprehensive tests for the MemoryTranslationEntryManager adapter.
 * Ensures correct storage and retrieval of translation entries with variants.
 */

import { describe, it, expect, beforeEach } from 'vitest';
import { MemoryTranslationEntryManager } from '../src/adapters/MemoryTranslationEntryManager';

describe('MemoryTranslationEntryManager', () => {
  let manager: MemoryTranslationEntryManager;

  beforeEach(() => {
    manager = new MemoryTranslationEntryManager();
  });

  describe('setEntry and getEntry', () => {
    it('should store and retrieve a simple entry', () => {
      const signature = ['meal'];
      manager.setEntry('en', 'orders', 'meal.title', signature, '{{meal}}', true);
      
      const entry = manager.getEntry('en', 'orders', 'meal.title', signature);
      
      expect(entry).toBeDefined();
      expect(entry?.value).toBe('{{meal}}');
      expect(entry?.variables).toEqual(['meal']);
      expect(entry?.autoGenerated).toBe(true);
    });

    it('should store multiple variants for the same key', () => {
      const sig1 = ['meal'];
      const sig2 = ['meal', 'price'];
      
      manager.setEntry('en', 'orders', 'meal.title', sig1, '{{meal}}', true);
      manager.setEntry('en', 'orders', 'meal.title', sig2, '{{meal}} - ${{price}}', true);
      
      const entry1 = manager.getEntry('en', 'orders', 'meal.title', sig1);
      const entry2 = manager.getEntry('en', 'orders', 'meal.title', sig2);
      
      expect(entry1?.value).toBe('{{meal}}');
      expect(entry2?.value).toBe('{{meal}} - ${{price}}');
    });

    it('should return null for non-existent entry', () => {
      const entry = manager.getEntry('en', 'orders', 'meal.title', ['meal']);
      expect(entry).toBeNull();
    });

    it('should return null for non-existent locale', () => {
      manager.setEntry('en', 'orders', 'meal.title', ['meal'], '{{meal}}');
      const entry = manager.getEntry('es', 'orders', 'meal.title', ['meal']);
      expect(entry).toBeNull();
    });

    it('should return null for non-existent namespace', () => {
      manager.setEntry('en', 'orders', 'meal.title', ['meal'], '{{meal}}');
      const entry = manager.getEntry('en', 'auth', 'meal.title', ['meal']);
      expect(entry).toBeNull();
    });

    it('should return null for non-existent key', () => {
      manager.setEntry('en', 'orders', 'meal.title', ['meal'], '{{meal}}');
      const entry = manager.getEntry('en', 'orders', 'meal.description', ['meal']);
      expect(entry).toBeNull();
    });

    it('should return null for non-existent signature', () => {
      manager.setEntry('en', 'orders', 'meal.title', ['meal'], '{{meal}}');
      const entry = manager.getEntry('en', 'orders', 'meal.title', ['meal', 'price']);
      expect(entry).toBeNull();
    });
  });

  describe('hasEntry', () => {
    it('should return true for existing entry', () => {
      manager.setEntry('en', 'orders', 'meal.title', ['meal'], '{{meal}}');
      expect(manager.hasEntry('en', 'orders', 'meal.title', ['meal'])).toBe(true);
    });

    it('should return false for non-existent entry', () => {
      expect(manager.hasEntry('en', 'orders', 'meal.title', ['meal'])).toBe(false);
    });

    it('should differentiate between different signatures', () => {
      manager.setEntry('en', 'orders', 'meal.title', ['meal'], '{{meal}}');
      
      expect(manager.hasEntry('en', 'orders', 'meal.title', ['meal'])).toBe(true);
      expect(manager.hasEntry('en', 'orders', 'meal.title', ['meal', 'price'])).toBe(false);
    });
  });

  describe('getAllVariants', () => {
    it('should return all variants for a key', () => {
      const sig1 = ['meal'];
      const sig2 = ['meal', 'price'];
      const sig3 = ['meal', 'price', 'quantity'];
      
      manager.setEntry('en', 'orders', 'meal.title', sig1, '{{meal}}');
      manager.setEntry('en', 'orders', 'meal.title', sig2, '{{meal}} - ${{price}}');
      manager.setEntry('en', 'orders', 'meal.title', sig3, '{{quantity}}x {{meal}} - ${{price}}');
      
      const variants = manager.getAllVariants('en', 'orders', 'meal.title');
      
      expect(variants).toBeDefined();
      expect(Object.keys(variants!.variants)).toHaveLength(3);
      expect(variants!.variants['meal']).toBeDefined();
      expect(variants!.variants['meal_price']).toBeDefined();
      expect(variants!.variants['meal_price_quantity']).toBeDefined();
    });

    it('should return null for non-existent key', () => {
      const variants = manager.getAllVariants('en', 'orders', 'meal.title');
      expect(variants).toBeNull();
    });

    it('should return null for non-existent locale', () => {
      manager.setEntry('en', 'orders', 'meal.title', ['meal'], '{{meal}}');
      const variants = manager.getAllVariants('es', 'orders', 'meal.title');
      expect(variants).toBeNull();
    });
  });

  describe('update behavior', () => {
    it('should update existing entry when set again', () => {
      manager.setEntry('en', 'orders', 'meal.title', ['meal'], '{{meal}}', true);
      manager.setEntry('en', 'orders', 'meal.title', ['meal'], 'Updated: {{meal}}', false);
      
      const entry = manager.getEntry('en', 'orders', 'meal.title', ['meal']);
      
      expect(entry?.value).toBe('Updated: {{meal}}');
      expect(entry?.autoGenerated).toBe(false);
    });

    it('should preserve timestamp on update', () => {
      manager.setEntry('en', 'orders', 'meal.title', ['meal'], '{{meal}}');
      
      const entry1 = manager.getEntry('en', 'orders', 'meal.title', ['meal']);
      const timestamp1 = entry1?.timestamp;
      
      // Wait a bit
      setTimeout(() => {
        manager.setEntry('en', 'orders', 'meal.title', ['meal'], 'Updated');
        
        const entry2 = manager.getEntry('en', 'orders', 'meal.title', ['meal']);
        const timestamp2 = entry2?.timestamp;
        
        expect(timestamp2).toBeGreaterThan(timestamp1!);
      }, 10);
    });
  });

  describe('multi-locale support', () => {
    it('should store entries for multiple locales independently', () => {
      manager.setEntry('en', 'orders', 'meal.title', ['meal'], 'Meal: {{meal}}');
      manager.setEntry('es', 'orders', 'meal.title', ['meal'], 'Comida: {{meal}}');
      manager.setEntry('fr', 'orders', 'meal.title', ['meal'], 'Repas: {{meal}}');
      
      const enEntry = manager.getEntry('en', 'orders', 'meal.title', ['meal']);
      const esEntry = manager.getEntry('es', 'orders', 'meal.title', ['meal']);
      const frEntry = manager.getEntry('fr', 'orders', 'meal.title', ['meal']);
      
      expect(enEntry?.value).toBe('Meal: {{meal}}');
      expect(esEntry?.value).toBe('Comida: {{meal}}');
      expect(frEntry?.value).toBe('Repas: {{meal}}');
    });
  });

  describe('multi-namespace support', () => {
    it('should store entries for multiple namespaces independently', () => {
      manager.setEntry('en', 'orders', 'title', ['meal'], 'Order: {{meal}}');
      manager.setEntry('en', 'auth', 'title', ['meal'], 'Auth: {{meal}}');
      manager.setEntry('en', 'common', 'title', ['meal'], 'Common: {{meal}}');
      
      const ordersEntry = manager.getEntry('en', 'orders', 'title', ['meal']);
      const authEntry = manager.getEntry('en', 'auth', 'title', ['meal']);
      const commonEntry = manager.getEntry('en', 'common', 'title', ['meal']);
      
      expect(ordersEntry?.value).toBe('Order: {{meal}}');
      expect(authEntry?.value).toBe('Auth: {{meal}}');
      expect(commonEntry?.value).toBe('Common: {{meal}}');
    });
  });

  describe('clear', () => {
    it('should clear all stored entries', () => {
      manager.setEntry('en', 'orders', 'meal.title', ['meal'], '{{meal}}');
      manager.setEntry('es', 'orders', 'meal.title', ['meal'], '{{meal}}');
      
      expect(manager.hasEntry('en', 'orders', 'meal.title', ['meal'])).toBe(true);
      
      manager.clear();
      
      expect(manager.hasEntry('en', 'orders', 'meal.title', ['meal'])).toBe(false);
      expect(manager.hasEntry('es', 'orders', 'meal.title', ['meal'])).toBe(false);
    });
  });

  describe('getAllForLocale', () => {
    it('should return all entries for a locale', () => {
      manager.setEntry('en', 'orders', 'meal.title', ['meal'], '{{meal}}');
      manager.setEntry('en', 'auth', 'login.button', [], 'Login');
      
      const allEntries = manager.getAllForLocale('en');
      
      expect(allEntries).toBeDefined();
      expect(allEntries?.has('orders')).toBe(true);
      expect(allEntries?.has('auth')).toBe(true);
    });

    it('should return null for non-existent locale', () => {
      const allEntries = manager.getAllForLocale('en');
      expect(allEntries).toBeNull();
    });
  });

  describe('real-world scenarios', () => {
    it('should handle complex multi-variant scenario', () => {
      // Scenario: A meal title that can be displayed in different ways
      
      // Variant 1: Just the meal name
      manager.setEntry('en', 'orders', 'meal.title', ['meal'], '{{meal}}');
      
      // Variant 2: Meal with price
      manager.setEntry('en', 'orders', 'meal.title', ['meal', 'price'], '{{meal}} - ${{price}}');
      
      // Variant 3: Meal with price and quantity
      manager.setEntry('en', 'orders', 'meal.title', ['meal', 'price', 'quantity'], 
        '{{quantity}}x {{meal}} - ${{price}} each');
      
      // Variant 4: Meal with restaurant
      manager.setEntry('en', 'orders', 'meal.title', ['meal', 'restaurant'], 
        '{{meal}} from {{restaurant}}');
      
      const variants = manager.getAllVariants('en', 'orders', 'meal.title');
      
      expect(Object.keys(variants!.variants)).toHaveLength(4);
      expect(variants!.variants['meal'].value).toBe('{{meal}}');
      expect(variants!.variants['meal_price'].value).toBe('{{meal}} - ${{price}}');
      expect(variants!.variants['meal_price_quantity'].value).toBe('{{quantity}}x {{meal}} - ${{price}} each');
      expect(variants!.variants['meal_restaurant'].value).toBe('{{meal}} from {{restaurant}}');
    });
  });
});
