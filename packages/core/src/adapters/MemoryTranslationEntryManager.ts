/**
 * ðŸ¥¯ i18n-bakery - Memory Translation Entry Manager (Adapter Layer)
 * 
 * Concrete implementation of the TranslationEntryManager interface.
 * Manages translation entries with variable signature support in memory.
 * 
 * @module adapters/MemoryTranslationEntryManager
 */

import {
  TranslationEntryManager,
  TranslationEntry,
  TranslationVariants,
  VariableSignature,
} from '../domain/VariableDetection';

/**
 * In-memory implementation of the TranslationEntryManager interface.
 * 
 * This adapter stores translation entries with support for multiple variants
 * based on variable signatures. It extends the existing MemoryStore concept
 * to handle the more complex variant structure.
 * 
 * Storage structure:
 * {
 *   "en": {
 *     "orders": {
 *       "meal.title": {
 *         "variants": {
 *           "meal": { value: "{{meal}}", variables: ["meal"], ... },
 *           "meal_price": { value: "{{meal}} - ${{price}}", variables: ["meal", "price"], ... }
 *         }
 *       }
 *     }
 *   }
 * }
 */
export class MemoryTranslationEntryManager implements TranslationEntryManager {
  /**
   * Internal storage structure
   * Map: locale -> namespace -> key -> TranslationVariants
   */
  private storage: Map<string, Map<string, Map<string, TranslationVariants>>> = new Map();

  /**
   * Gets a translation entry for a specific key and variable signature.
   */
  getEntry(
    locale: string,
    namespace: string,
    key: string,
    signature: VariableSignature
  ): TranslationEntry | null {
    const variants = this.getAllVariants(locale, namespace, key);
    if (!variants) {
      return null;
    }

    const signatureKey = this.createSignatureKey(signature);
    return variants.variants[signatureKey] || null;
  }

  /**
   * Creates or updates a translation entry.
   */
  setEntry(
    locale: string,
    namespace: string,
    key: string,
    signature: VariableSignature,
    value: string,
    autoGenerated: boolean = false
  ): void {
    // Ensure locale exists
    if (!this.storage.has(locale)) {
      this.storage.set(locale, new Map());
    }

    const localeMap = this.storage.get(locale)!;

    // Ensure namespace exists
    if (!localeMap.has(namespace)) {
      localeMap.set(namespace, new Map());
    }

    const namespaceMap = localeMap.get(namespace)!;

    // Ensure key exists
    if (!namespaceMap.has(key)) {
      namespaceMap.set(key, { variants: {} });
    }

    const variants = namespaceMap.get(key)!;
    const signatureKey = this.createSignatureKey(signature);

    // Create or update the entry
    variants.variants[signatureKey] = {
      value,
      variables: [...signature],
      autoGenerated,
      timestamp: Date.now(),
    };
  }

  /**
   * Checks if an entry exists for a specific key and signature.
   */
  hasEntry(
    locale: string,
    namespace: string,
    key: string,
    signature: VariableSignature
  ): boolean {
    const entry = this.getEntry(locale, namespace, key, signature);
    return entry !== null;
  }

  /**
   * Gets all variants for a specific key.
   */
  getAllVariants(
    locale: string,
    namespace: string,
    key: string
  ): TranslationVariants | null {
    const localeMap = this.storage.get(locale);
    if (!localeMap) {
      return null;
    }

    const namespaceMap = localeMap.get(namespace);
    if (!namespaceMap) {
      return null;
    }

    return namespaceMap.get(key) || null;
  }

  /**
   * Helper method to create a signature key from a signature.
   * This is duplicated from DefaultVariableDetector to avoid circular dependencies.
   * In a real-world scenario, this could be extracted to a shared utility.
   */
  private createSignatureKey(signature: VariableSignature): string {
    if (!signature || signature.length === 0) {
      return 'default';
    }
    return signature.join('_');
  }

  /**
   * Clears all stored entries (useful for testing).
   */
  clear(): void {
    this.storage.clear();
  }

  /**
   * Gets all entries for a locale (useful for debugging/inspection).
   */
  getAllForLocale(locale: string): Map<string, Map<string, TranslationVariants>> | null {
    return this.storage.get(locale) || null;
  }
}
